{"pages":[],"posts":[{"title":"Hello World","text":"失败的可以使用yarn代替npm","link":"/hexo/2019/09/29/hello-world/"},{"title":"java线程池简单实现","text":"线程池代码实现​ 单纯练习Java并发编程，还没看完线程池实现的源代码，自己写的，如有错误希望指正，尽可能在保证线程安全的情况下，使用非锁实现。可能存在效率等问题，仅供学习参考。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.atomic.AtomicInteger;public class ThreadPoolDemo implements Runnable { //初始化大小 private int init; //当前线程数量 private AtomicInteger count ; //工作线程数量 private AtomicInteger workQuantity = new AtomicInteger(0); //等待线程数量 private AtomicInteger waitQuantity = new AtomicInteger(0); //最大线程数 private int max; //线程存活时间(单位毫秒) private long mills = 60*1000; //状态位，线程池停止状态 private volatile boolean status ; private BlockingQueue&lt;Runnable&gt; queue ; /** * * @param init 最大线程池数量 * @param max 最大等待队列长度 */ public ThreadPoolDemo(int init,int max){ this.init = init; this.max = max; count= new AtomicInteger(0); queue = new ArrayBlockingQueue&lt;&gt;(max); status = true; } /** * * @param runnable 将要执行的任务 * @return 提交任务是否成功 */ public boolean submit(Runnable runnable) { boolean offerStatus = false; synchronized (this){ offerStatus = queue.offer(runnable); if(waitQuantity.get()==0&amp;&amp;workQuantity.get()&lt;init){ //工作线程+1 workQuantity.getAndAdd(1); new Thread(this).start(); } } synchronized (queue){ queue.notify(); } return offerStatus; } /** * * @return返回当前状态工作线程数量 */ public int getCurrentWorkThreadQuantity(){ return workQuantity.get(); } /** * * @return返回当前状态下等待态线程数量 */ public int getCurrentWaitQuantity(){ return waitQuantity.get(); } /** * * @return阻塞队列中等待的任务数量 */ public int getRemaining(){ return queue.size(); } /** * 等待正在执行的任务结束，关闭线程池 */ public void shutdown(){ //清空队列 status = false; queue.clear(); synchronized(queue){ queue.notifyAll(); } } @Override public void run(){ while(true){ Runnable work = null; synchronized(queue){ //计算超时时间 long future = System.currentTimeMillis() + mills; while (queue.isEmpty()){ try { //判断是否超时 if(!status||(future - System.currentTimeMillis())&lt;0){ //工作线程-1 workQuantity.getAndDecrement(); return; } //等待线程+1 waitQuantity.getAndAdd(1); queue.wait(mills); //等待线程-1 waitQuantity.getAndAdd(-1); } catch (InterruptedException e) { e.printStackTrace(); } } work = queue.poll(); } if(work!=null){ work.run(); } } }} 测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.cx.demo1;/** * @ClassName: com.cx.demo1 * @description: 线程池测试类 * @team:zua * @author: cx * @createdatatime: 2019-10-06 19:40 **/public class TestThreadPool { public static void main(String[] args) { Calculation calculation = new Calculation(); ThreadPoolDemo threadPoolDemo = new ThreadPoolDemo(4,20); for(int i = 0 ;i &lt; 2 ;i++){ threadPoolDemo.submit(calculation); } try { Thread.sleep(1*1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"init+++++\"); System.out.println(\"worker :\"+ threadPoolDemo.getCurrentWorkThreadQuantity()); System.out.println(\"waiter :\"+threadPoolDemo.getCurrentWaitQuantity()); for(int i = 0 ;i &lt; 4 ;i++){ threadPoolDemo.submit(calculation); } try { Thread.sleep(1*1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"++++9++run\"); System.out.println(\"worker :\"+threadPoolDemo.getCurrentWorkThreadQuantity()); System.out.println(\"waiter :\"+threadPoolDemo.getCurrentWaitQuantity()); try { Thread.sleep(50*1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"sleep++++\"); System.out.println(\"worker :\"+threadPoolDemo.getCurrentWorkThreadQuantity()); System.out.println(\"waiter :\"+threadPoolDemo.getCurrentWaitQuantity()); for(int i = 0 ;i &lt; 50 ;i++){ String submitStatus = threadPoolDemo.submit(calculation)?\"success\":\"failure\"; System.out.println(submitStatus); } System.out.println(\"shutdown ++++++before\"); System.out.println(\"worker :\"+threadPoolDemo.getCurrentWorkThreadQuantity()); System.out.println(\"waiter :\"+threadPoolDemo.getCurrentWaitQuantity()); threadPoolDemo.shutdown(); try { Thread.sleep(10*1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"shutdown +++++ after\"); System.out.println(\"worker :\"+threadPoolDemo.getCurrentWorkThreadQuantity()); System.out.println(\"waiter :\"+threadPoolDemo.getCurrentWaitQuantity()); }}class Calculation implements Runnable{ @Override public void run() { try { Thread.sleep(10*1000); } catch (InterruptedException e) { e.printStackTrace(); } }} 期望效果​ 当任务数量小于线程池最大数量时，为每个任务创建线程，任务完成后等待60秒，无新的任务则释放线程， 当任务数量大于最大线程数量时，将任务加入阻塞队列，阻塞队列满后拒绝新的任务。工作线程完成任务后，去阻塞队列取新的任务执行。","link":"/hexo/2019/10/06/java线程池简单实现/"},{"title":"mysql基础","text":"mysql基本操作 创建数据库123create database test ; -- 默认方式创建数据库create database test character set utf8; -- 指定字符集创建数据库 用户管理用户管理对应mysql.user表，修改对应数据库即可 1234567891011121314151617-- 新增用户GRANT ALL PRIVILEGES on test.* to test@localhost IDENTIFIED by &apos;test&apos;;-- 查看用户权限SHOW GRANTS FOR test@localhost;-- 增加用户权限GRANT INSERT on test.* to test@localhost;-- 减少用户权限REVOKE INSERT on sdgx.* from test@localhost;-- 删除用户DELETE FROM user WHERE user=&apos;test&apos; AND WHERE host=&apos;localhost&apos;;-- 忘记mysql root账户密码（linux）systemctl stop mysql -- 关闭mysqlmysqld --skip-grant-tables -- 跳过校验-- 修改密码pkill mysqld -- 杀掉进程systemctl restart mysql -- 重启mysql 范式 1-NF 第一范式表中所有字段都是不可分割的原子集。(比如：地址可以拆分为省、市、县，将其拆开三个字段则满足第一范式，否则不满足)。 2-NF 第二范式首先满足第一范式，每一列（除主键）都完全依赖与主键。（使用联合主键，某一列仅对联合主键的其中部分主键构成依赖，则不满足第二范式） ####3-NF 第三范式 首次满足第二范式，除主键外其特列不能有传递依赖关系（即除主键外其它列不对任一列构成依赖关系） 创建数据表 1234567891011121314151617181920212223242526272829303132333435create table user( ID int(11), name varchar(20), sex char(1), birth DATE); -- 创建数据库表并指明列名与数据大小create table user( ID int(11) not null COMMENT &quot;主键&quot;， -- 不可为空，备注主键 name varchar(20) null COMMENT &quot;姓名&quot;, -- 可为空，备注姓名 sex char(1) not null COMMENT &quot;性别&quot;， -- 不可为空，备注性别 birth DATE COMMENT &quot;生日&quot;, -- 默认可为空，备注生日 PRIMARY KEY(ID) -- 设置ID为主键);-- 修改字段属性(添加自增约束)ALTER TABLE user MODIFY COLUMN ID int(10) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;；-- 删除主键约束ALTER TABLE user DROP PRIMARY KEY;-- 查看表字段信息DESCRIBE user;(简写：DESC user;)-- 添加唯一约束ALTER TABLE user ADD UNIQUE(id);//创建表时添加参考主键；-- 删除唯一约束ALTER TABLE user DROP INDEX id;-- 修改默认约束ALTER TABLE user MODIFY COLUMN sex char(1) default &apos;M&apos; not null;-- 添加列ALTER TABLE user ADD COLUMN test varchar(20);-- 删除列ALTER TABLE user DROP COLUMN test;-- 外键(外键所链接的列必须为主键)create table u_order(id int(11), W_id int(11),foreign key(w_id) references user(id));-- 数据类型int(11) -- 表示占用一个int（4字节）,显示长度10位，头默认填充0，超过会截断 插入数据 12345-- 插入一条数据INSERT INTO user (id,name,sex,birth) value (&apos;1&apos;,&apos;test&apos;,&apos;M&apos;,now());-- 插入多条数据INSERT INTO user (id,name,sex,birth) value (&apos;2&apos;,&apos;test2&apos;,&apos;S&apos;,now()),(&apos;3&apos;,&apos;test3&apos;,&apos;M&apos;,now()); 修改数据1UPDATE user SET id=1 WHERE id=2; 删除数据1DELETE FROM user WHERE id=1;-- 删除user表id为1的数据 查询123456789101112-- 连表查询select * from user,u_order where user.id=U_order.W_id;-- 子查询select * from user where id in (select W_id from u_order);-- 求并集(列数应该相同)select id from user union select id from u_order;-- 查询结果排序(desc:倒序)select id from user order by id desc;-- 查询指定区间的数据select * from user limit start,length;-- 分组聚合查询select count(number) from user group by name; 事务事务是最小的不可分割的工作单元,事务能保证一个业务的完整性。 事务的特征ACID： A:atomicity:原子性:事务是最小执行单位，不可分割 C:consistency: 一致性:事务要求，同一事务中SQL语句，必须同时成功或者失败。 I:isolation: 隔离性:事务1和事务2之间具有隔离性。 D:durability:持久性:事务一旦结束不可以回滚 //关闭mysql自动提交 12345678set autocommit=0;-- 手动提交事务commit；-- 手动回滚rollback；-- 手动开启事务begin;start transaction; 事务隔离级别： read uncommitted; 读未提交的 不加锁一般不用 read committed; 读已提交的 读不加锁，添加、修改、删除需要加锁 repeatable read; 可重复读 MySQL通过版本控制（MVCC）实现读不加锁，不通过MVCC实现需要加读锁 serializanle 串行化 所有读写均加锁 查看数据库隔离级别 12345678910111213141516-- 查看数据库全局隔离级别select @@global.transaction_isolation;select @@global.tx_isolation; -- mariadb或mysql5.*-- 查看数据会话级隔离级别select @@transaction_isolation;select @@tx_isolation; -- mariadb或mysql5.*-- 修改数据库隔离级别set global transaction isolation level read uncommitted;-- 全局set transaction isolation level read uncommitted; -- 会话级别-- 读未提交，可能由于事务回滚造成脏读set global transaction isolation level read committed;-- 读已提交，可能不可重复读（另一事务修改数据之后，另一事务内多次读同一表数据的值不同）set global transaction isolation level repeatable read;-- 重复读，可能发生幻读（另一事务提交的数据，不能在事务结束前被其它事务获取）set global transaction isolation level serializable;-- 串行化 ，另一操作该表的事务阻塞，可能死锁（mysql自带死锁检查）； 索引12//创建索引 索引名前缀 idx_create index idx_user_name on user(name);","link":"/hexo/2019/10/01/mysql基础/"}],"tags":[{"name":"Java SE","slug":"Java-SE","link":"/hexo/tags/Java-SE/"},{"name":"console","slug":"console","link":"/hexo/tags/console/"},{"name":"线程池","slug":"线程池","link":"/hexo/tags/线程池/"},{"name":"并发编程","slug":"并发编程","link":"/hexo/tags/并发编程/"},{"name":"锁","slug":"锁","link":"/hexo/tags/锁/"},{"name":"线程同步","slug":"线程同步","link":"/hexo/tags/线程同步/"},{"name":"线程线程池","slug":"线程线程池","link":"/hexo/tags/线程线程池/"},{"name":"mysql","slug":"mysql","link":"/hexo/tags/mysql/"},{"name":"mariadb","slug":"mariadb","link":"/hexo/tags/mariadb/"},{"name":"基础","slug":"基础","link":"/hexo/tags/基础/"},{"name":"增删改查","slug":"增删改查","link":"/hexo/tags/增删改查/"},{"name":"用户管理","slug":"用户管理","link":"/hexo/tags/用户管理/"},{"name":"事务","slug":"事务","link":"/hexo/tags/事务/"},{"name":"索引","slug":"索引","link":"/hexo/tags/索引/"}],"categories":[]}